using System.Net.Http;

namespace project3
{
    internal class Program
    {
        private static readonly HttpClient client = new HttpClient();

        static async Task Main(string[] args)
        {
            try
            {
                if (BrokerAndValidator.valid_argument(args))
                {
                    await BrokerAndValidator.process_argument(args, client);
                }
                else
                {
                    BrokerAndValidator.PrintErrorMessage();
                }
            }
            catch
            {
                BrokerAndValidator.PrintErrorMessage();
            }
        }
    }

    internal class BrokerAndValidator
    {
        public static void PrintErrorMessage()
        {
            string errorMessage =
                "Usage: dotnet run <command> <argument>\n\n"
                + "Available commands:\n"
                + "- keyGen  <int>.....................Generate a keypair with <int> number of bits abd store them in public.key and private.key\n"
                + "- sendKey <email>...................Send a public key generated by keyGen to the server. This should be your email address.\n"
                + "- getKey  <email>...................Retrieve a public key for a particular user.\n"
                + "- sendMsg <email> <\"plain text\">....Send a message to a user. Ensure you have a public key for that user.\n"
                + "- getMsg  <email>...................Retrieve a message for a user. You can get any user but you will only be able to use your private key to decode\n\n";
            Console.WriteLine(errorMessage);
        }

        static async Task getKey(string email, HttpClient client)
        {
            Console.WriteLine($"{email}");
            try
            {
                HttpResponseMessage response = await client.GetAsync(
                    $"http://voyager.cs.rit.edu:5050/Key/{email}"
                );
                if (response.IsSuccessStatusCode)
                {
                    string responseBody = await response.Content.ReadAsStringAsync();
                    if (string.IsNullOrEmpty(responseBody))
                    {
                        Console.WriteLine("Empty response body");
                    }
                    else
                    {
                        File.WriteAllText($"{email}.key", responseBody);
                        Console.WriteLine("Key has been written to key.txt");
                    }
                }
                else
                {
                    Console.WriteLine($"Failed to fetch data. Status code: {response.StatusCode}");
                    PrintErrorMessage();
                }
            }
            catch
            {
                PrintErrorMessage();
            }
        }

        public static async Task process_argument(string[] args, HttpClient client)
        {
            try
            {
                switch (args[0])
                {
                    case "keyGen":
                    case "sendKey":
                    case "sendMsg":
                    case "getMsg":
                        break;
                    case "getKey":
                        await getKey(args[1], client);
                        break;
                    default:
                        break;
                }
            }
            catch
            {
                PrintErrorMessage();
            }
        }

        public static bool valid_argument(string[] args)
        {
            try
            {
                if (args.Length != 2)
                {
                    return false;
                }

                switch (args[0])
                {
                    case "keyGen":
                        return int.TryParse(args[1], out _);
                    case "sendKey":
                    case "getKey":
                    case "sendMsg":
                    case "getMsg":
                        return args[1] is string;
                    default:
                        return false;
                }
            }
            catch
            {
                return false;
            }
        }
    }
}
